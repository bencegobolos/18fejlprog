Feladatkiírás

A feladat olyan osztálysablon írása, amely egy bináris fa pontját valósítja meg
(sablon és osztály példányosítás után pedig az objektumok együtt bináris fát
alkotnak). A fapontokban tárolt adatok típusát a sablon paramétere határozza
meg.

A fapontokon legyenek hívhatók olyan metódusok, amelyek hozzáférést
biztosítanak a tárolt adathoz, valamint a fapont szülõjéhez és gyerekeihez. A
szülõt és gyerekeket beállító metódusoknak biztosítaniuk kell, hogy a
kapcsolatok mindig konzisztensek maradjanak. (Azaz ha egy fapontnak beállítjuk
egy gyerekét, akkor az új gyereknek megfelelõen be kell állítani a szülõjét. Ha
egy részfát áthelyezünk, akkor nem hivatkozhat tovább a korábbi szülõ az
áthelyezett részfára, mint gyerekére. Stb.)

A fa(pont) adatszerkezetnek rendelkeznie kell iterátorral, amely a ++ mûvelet
hatására a fa pontjainak inorder (bal gyerek - fapont - jobb gyerek) bejárását
biztosítja. A dereferencia operátoroknak a fapontokban tárolt adatokhoz való
hozzáférést kell biztosítania.

Az osztálysablon publikus interfésze (a sablon neve, a sablonparaméterezése, a
publikus metódusainak szignatúrája) kötött, azaz legalább az alábbiaknak meg
kell felelnie (de amennyiben a feladatkiírás szükségessé teszi további publikus
metódusokkal, belsõ típusokkal bõvíthetõ, valamint az osztály törzsén kívül is
szerepelhetnek további típusok, metódusok):

// === MEGVALÓSÍTANDÓ ===

/**
 * Az osztálysablon neve my_tree.
 * A sablon paraméterezése:
 *   - T: a fapontokban tárolt adat típusa
 * A sablonpéldány a tree_base osztályból származik (amely rendelkezik default
 * konstruktorral). A beadott feladatban a tree_base osztályt nem kell (nem
 * szabad) megvalósítani!
 */
template<class T>
class my_tree : tree_base {
public:
    /**
     * Belsõ osztály, amely az inorder bejárást biztosító iterátort valósítja meg.
     */
    class iterator;
    /** A sablonpéldány rendelkezik default konstruktorral. */
    my_tree();
    /**
     * A sablonpéldány rendelkezik olyan konstruktorral, amely inicializálja a
     * fapontban tárolt adatot.
     */
    my_tree(const T &data);
    /**
     * A sablonpéldány rendelkezik olyan konstruktorral, amely inicializálja a
     * fapontban tárolt adatot, és a bal és jobb gyerekét.
     */
    my_tree(const T &data, my_tree<T> *left, my_tree<T> *right);
    /** A destruktor felszabadítja a teljes részfát. */
    ~my_tree();
    /** Hozzáférés a fapontban tárolt adathoz. */
    const T& data() const;
    T& data();
    /** A fapont szülõje. */
    my_tree<T>* parent() const;
    /** A fapont bal gyereke. */
    my_tree<T>* leftChild() const;
    /** A fapont jobb gyereke. */
    my_tree<T>* rightChild() const;
    /** Beállítja a fapont bal gyerekét. */
    void setLeftChild(my_tree<T> *left);
    /** Beállítja a fapont jobb gyerekét. */
    void setRightChild(my_tree<T> *right);
    /** Iterátor típus, amely inorder bejárást biztosít a fában. */
    class iterator;
    /** Iterátor a fa inorder bejárás szerinti elsõ elemére. */
    iterator begin();
    /** Iterátor a fa inorder bejárás szerinti utolsó eleme utáni elemre. */
    iterator end();
};

// === MEGVALÓSÍTÁS VÉGE ===

/**
 * Példa a fa adatszerkezet felhasználására. A beadott feladatban nem szabad
 * szerepelnie.
 */
int main() {
    my_tree<int> *tree = new my_tree<int>(8, new my_tree<int>(7), new my_tree<int>(9));

	cout << *tree->begin();

    return 0;
}
